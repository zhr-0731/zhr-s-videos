name: repo-access-check-and-notify

# 每两个小时一次，UTC 时间 07:00 ~ 21:00（07,09,11,13,15,17,19,21）
on:
  schedule:
    - cron: '0 7-21/2 * * *'
  workflow_dispatch:

permissions:
  contents: read

env:
  REPOS: "zhr-0731/zhr-s-videos"
  # 固定收件人（每次运行都发送状态邮件到这两个地址）
  FIXED_RECIPIENTS: "zhr_955@sina.com,zhr_898@qq.com"
  # 触发自动回复的允许发件人列表（IMAP 检查时匹配）
  ALLOWED_QUERY_SENDERS: "13974478440@139.com,zhr_955@sina.com,zhr_898@qq.com,suibian1666@petalmail.com"
  QUERY_MATCH_TEXT: "查询zhr-s-videos"

jobs:
  check-repos:
    runs-on: ubuntu-latest

    steps:
      - name: Choose token
        id: choose-token
        run: |
          if [ -n "${{ secrets.CHECK_TOKEN }}" ]; then
            echo "token=${{ secrets.CHECK_TOKEN }}" >> $GITHUB_OUTPUT
            echo "Using CHECK_TOKEN"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "Using GITHUB_TOKEN"
          fi

      - name: Check repository accessibility
        id: check
        run: |
          IFS=',' read -ra REPO_LIST <<< "${REPOS}"
          failed=0
          plain_body="仓库可访问性检查运行时间：$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") UTC\n\n"
          for r in "${REPO_LIST[@]}"; do
            repo=$(echo "$r" | xargs)
            echo "Checking $repo ..."
            status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ steps.choose-token.outputs.token }}" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$repo")
            if [ "$status" != "200" ]; then
              failed=$((failed+1))
              plain_body="$plain_body- $repo -> HTTP $status\n"
            else
              plain_body="$plain_body- $repo -> OK (HTTP $status)\n"
            fi
          done

          echo "failed=${failed}" >> $GITHUB_OUTPUT
          echo "plain_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "$plain_body" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build HTML status email
        id: build-html
        run: |
          FAILED=${{ steps.check.outputs.failed }}
          SUMMARY="${{ steps.check.outputs.plain_body }}"
          REPOS_ESCAPED="${REPOS}"

          html="<!doctype html>\n<html lang=\"zh-CN\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans','Microsoft YaHei',sans-serif;background:#f5f7fa;margin:0;padding:20px;color:#333}\n  .card{max-width:760px;margin:0 auto;background:#fff;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.08);overflow:hidden}\n  .header{padding:20px 24px;background:linear-gradient(90deg,#4f46e5,#06b6d4);color:#fff}\n  .title{font-size:18px;margin:0}\n  .time{font-size:12px;opacity:0.95;margin:4px 0 0}\n  .content{padding:18px 24px}\n  table{width:100%;border-collapse:collapse;margin-top:8px}\n  th,td{padding:12px 10px;text-align:left;border-bottom:1px solid #f0f0f0}\n  th{background:#fafafa;font-weight:600}\n  .status-ok{color:#16a34a;font-weight:700}\n  .status-fail{color:#dc2626;font-weight:700}\n  .footer{padding:12px 24px;font-size:13px;color:#666;background:#fbfbfb}\n  pre{white-space:pre-wrap;font-family:inherit;background:transparent;border:none;padding:0;margin:0}\n</style>\n</head>\n<body>\n  <div class=\"card\">\n    <div class=\"header\">\n      <p class=\"title\">仓库可访问性状态报告</p>\n      <p class=\"time\">运行时间：$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") UTC</p>\n    </div>\n    <div class=\"content\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px\">\n        <div>检测对象：<strong>${REPOS_ESCAPED}</strong></div>\n        <div><span style=\"display:inline-block;padding:6px 10px;border-radius:999px;background:${FAILED##0:+#ef4444};color:#fff;font-weight:700\">${FAILED:-0} 异常</span></div>\n      </div>\n      <table>\n        <thead><tr><th>仓库</th><th>状态</th></tr></thead>\n        <tbody>\n"

          IFS=',' read -ra REPO_LIST <<< "${REPOS}"
          for r in "${REPO_LIST[@]}"; do
            repo=$(echo "$r" | xargs)
            status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ steps.choose-token.outputs.token }}" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$repo")
            if [ "$status" = "200" ]; then
              row="<tr><td>${repo}</td><td class=\"status-ok\">✅ 可访问 (HTTP ${status})</td></tr>\n"
            else
              row="<tr><td>${repo}</td><td class=\"status-fail\">❌ 不可访问 (HTTP ${status})</td></tr>\n"
            fi
            html+=$row
          done

          html+="</tbody>\n      </table>\n    </div>\n    <div class=\"footer\">\n      <p style=\"margin:0 0 8px\">摘要：${FAILED} 个异常</p>\n      <pre>${SUMMARY}</pre>\n    </div>\n  </div>\n</body>\n</html>"

          # export outputs
          echo "html<<EOF" >> $GITHUB_OUTPUT
          echo -e "$html" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send status email to fixed recipients (always)
        if: always()
        continue-on-error: true
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          # 如果使用 465 -> secure: true；如果使用 587(STARTTLS) -> secure: false
          secure: true
          from: ${{ secrets.EMAIL_FROM }}
          to: ${{ env.FIXED_RECIPIENTS }}
          subject: "[状态] 仓库可访问性报告 — ${{ steps.check.outputs.failed }} 个异常"
          body: ${{ steps.build-html.outputs.html }}
          content_type: text/html

      - name: Check mailbox for incoming queries and reply (optional IMAP)
        if: ${{ secrets.IMAP_SERVER != '' && secrets.IMAP_USERNAME != '' && secrets.IMAP_PASSWORD != '' }}
        env:
          IMAP_SERVER: ${{ secrets.IMAP_SERVER }}
          IMAP_PORT: ${{ secrets.IMAP_PORT }}
          IMAP_USERNAME: ${{ secrets.IMAP_USERNAME }}
          IMAP_PASSWORD: ${{ secrets.IMAP_PASSWORD }}
          SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          ALLOWED_SENDERS: ${{ env.ALLOWED_QUERY_SENDERS }}
          QUERY_TEXT: ${{ env.QUERY_MATCH_TEXT }}
        run: |
          python3 - <<'PY'
          import imaplib, email, os, smtplib, ssl
          from email.message import EmailMessage
          from email.utils import parseaddr

          imap_server = os.environ.get("IMAP_SERVER")
          imap_port = int(os.environ.get("IMAP_PORT") or 993)
          imap_user = os.environ.get("IMAP_USERNAME")
          imap_pwd = os.environ.get("IMAP_PASSWORD")
          smtp_server = os.environ.get("SMTP_SERVER")
          smtp_port = int(os.environ.get("SMTP_PORT") or 465)
          smtp_user = os.environ.get("SMTP_USERNAME")
          smtp_pwd = os.environ.get("SMTP_PASSWORD")
          email_from = os.environ.get("EMAIL_FROM")
          allowed = [s.strip().lower() for s in os.environ.get("ALLOWED_SENDERS","").split(",") if s.strip()]
          qtext = os.environ.get("QUERY_TEXT","查询zhr-s-videos")

          # load status HTML and plain summary from files generated by workflow outputs
          # The build-html output is available via env interpolation above; as simpler approach, reconstruct
          html = os.environ.get("BUILD_HTML") or None
          # If GITHUB_OUTPUT html not passed, try to read from env variable (GitHub Actions sets outputs)
          if not html:
            # attempt to read from file if present
            try:
              with open('/tmp/status_email.html','r',encoding='utf-8') as f:
                html = f.read()
            except Exception:
              html = "<p>无法获取状态内容</p>"
          plain = os.environ.get("PLAIN_BODY") or "仓库可访问性检查结果"

          # Connect to IMAP and search UNSEEN messages
          try:
            M = imaplib.IMAP4_SSL(imap_server, imap_port)
            M.login(imap_user, imap_pwd)
            M.select("INBOX")
            typ, data = M.search(None, '(UNSEEN)')
            if typ != 'OK':
              print("IMAP search failed:", typ, data)
            msg_nums = data[0].split()
            reply_to_list = set()
            for num in msg_nums:
              typ, msg_data = M.fetch(num, '(RFC822)')
              if typ != 'OK':
                continue
              raw = msg_data[0][1]
              msg = email.message_from_bytes(raw)
              subj = msg.get('Subject','')
              fr = parseaddr(msg.get('From'))[1].lower()
              # get body text
              body = ""
              if msg.is_multipart():
                for part in msg.walk():
                  ctype = part.get_content_type()
                  if ctype == 'text/plain' and part.get_content_disposition() in (None, 'inline'):
                    try:
                      body += part.get_payload(decode=True).decode(part.get_content_charset() or 'utf-8', errors='ignore')
                    except:
                      body += str(part.get_payload(decode=True))
              else:
                try:
                  body = msg.get_payload(decode=True).decode(msg.get_content_charset() or 'utf-8', errors='ignore')
                except:
                  body = str(msg.get_payload(decode=True))
              # match subject and body containing query text, and sender in allowed list
              if qtext in (subj or "") or qtext in (body or ""):
                if fr in allowed:
                  reply_to_list.add(fr)
              # mark seen to avoid repeated replies
              M.store(num, '+FLAGS', '\\Seen')
            M.logout()
          except Exception as e:
            print("IMAP check failed:", e)
            reply_to_list = set()

          # prepare email content (use environment HTML if provided)
          # try read ACTION output for build-html if available
          html_content = os.environ.get("HTML_CONTENT")
          if not html_content:
            # try to fetch build-html output from environment variable substitution set by step (may not exist)
            html_content = os.environ.get("GITHUB_ENV_HTML","")
          if not html_content:
            # fallback: very simple HTML body built from plain
            html_content = "<pre>{}</pre>".format(plain)

          # send status email to each requester
          def send_mail(to_addr):
            try:
              msg = EmailMessage()
              subj = "[状态] 仓库可访问性报告 — %s" % (plain.splitlines()[2] if len(plain.splitlines())>2 else "")
              msg['Subject'] = subj
              msg['From'] = email_from
              msg['To'] = to_addr
              msg.set_content(plain)
              msg.add_alternative(html_content, subtype='html')

              # choose SMTP connection mode depending on port
              if smtp_port == 465:
                context = ssl.create_default_context()
                with smtplib.SMTP_SSL(smtp_server, smtp_port, context=context) as s:
                  s.login(smtp_user, smtp_pwd)
                  s.send_message(msg)
              else:
                with smtplib.SMTP(smtp_server, smtp_port) as s:
                  s.ehlo()
                  s.starttls(context=ssl.create_default_context())
                  s.login(smtp_user, smtp_pwd)
                  s.send_message(msg)
              print("Sent status email to", to_addr)
            except Exception as e:
              print("Failed to send to", to_addr, e)

          for to_addr in reply_to_list:
            send_mail(to_addr)
          print("Reply list:", reply_to_list)
          PY
        # pass build-html outputs into files/env so python can use them (best-effort)
        # write outputs to temporary files for python step to read
        shell: bash
        env:
          HTML_CONTENT: ${{ steps.build-html.outputs.html }}
          PLAIN_BODY: ${{ steps.check.outputs.plain_body }}
        run: |
          # create temp files for python step (already supplied via env above)
          echo "$HTML_CONTENT" > /tmp/status_email.html || true
          echo "$PLAIN_BODY" > /tmp/status_email.txt || true
